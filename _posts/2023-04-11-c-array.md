---
layout: post
title: C语言中的数组
categories: [C]
description: C语言中的数组
keywords: C, 数组
---

## 一维数组

### 定义

```
[存储类型] 数组类型 标识符[下标]
```

### 初始化

不初始化:

```
int arr[3];
```

全部初始化：

```
int arr[3] = {1,2,3};
```

部分初始化：

```
int arr[3] = {1};
```
### 元素引用

```
数组名[下标]
```

看如下代码，输出数组元素的地址：
```
int arr[3];
int i;
printf("arr = %p\n", arr);
for(i = 0;i < 3; i++)
    printf("%p --> %d\n", &arr[i], arr[i]);
```

输出结果：
```
arr = 0x7ffdd815af1c
0x7ffdd815af1c --> 1
0x7ffdd815af20 --> 0
0x7ffdd815af24 --> 0
```
数组元素地址直接间隔为4，可以说明数组的地址空间是连续的，且每个元素占用4个字节大小。数组的地址与数组元素的第一个地址是一致的。

未初始化的数组，数组元素的值为原始值（不确定的），static修饰的int数组，会默认初始化为0；
### 数组名

数组名是表示数组地址的常量（也就是数组的起始位置），所有数组名不能无条件出现等号的左边。例如下面写法就是错误的：
```
int arr[3];
arr = {4,5,6};
```

### 数组越界

数组越界是不检查的，数组越界是不会报错的。
```
int arr[3];
arr[3] = 10;
printf("arr[3] = %d\n", arr[3]);
```
输出结果：
```
arr[3] = 10
```
## 二维数组

二维可以理解为存储元素为数组的数组，有一个两行三列的数组int a[2][3]，可以理解为数组a有两个元素，每个元素是一个有3个元素的数组。所以二维数组数据就是多个一维数组的组成的连续存储的空间。



### 定义，初始化

```
[存储类型] 数据类型 标识符[行下标][列下标]
```
int a[2][3]存储示意图：
![int a[2][3]存储示意图](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/c/2d_array.png?raw=true)

int a[2][3]在内存中的实际的存储方式示意图：
![int a[2][3]内存存储示意图](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/c/2d_array_in_memory.png?raw=true)

初始化：
```
int a[2][3] = {{1,2,3},{4,5,6}};
```

部分初始化：
```
//未初始化的元素自动赋0值
int a[2][3]={{1,2,3}};
int b[2][3]={{1,3},{4}};

//自动给各个元素挨着赋值
int c[2][3]={1,2,3,4,5};

//这种情况可以省略行号，自动推算出行，但是不能省略列号
int d[][3]={1,3,4,6,7};
```


### 元素引用

```
数组名[行标][列标]
```
### 存储形式

示例1：
```
int a[2][3]={{1,2,3},{4,5,6}};
int i,j;

printf("a = %p\n", a);
for(i=0;i<2;i++){
    for(j=0;j<3;j++){
        printf("%p --> %d\n", &a[i][j], a[i][j]);
    }
}
```
输出结果：
```
a = 0x7ffd1e49e7e0
0x7ffc4ab54370 --> 1
0x7ffc4ab54374 --> 2
0x7ffc4ab54378 --> 3
0x7ffc4ab5437c --> 4
0x7ffc4ab54380 --> 5
0x7ffc4ab54384 --> 6
```

输出结果中每个每个元素的地址间隔为4个字节，说明二维数据的内存存放的地址是连续的。并且数组名和数组的首个元素的地址相同，说明地址名就存储的是二维数据的首地址。

### 对于二维数组的深入理解

## 字符数组