---
layout: post
title: MySQL InnoDB中的AUTO_INCREMENT
categories: [MySQL]   
description: MySQL InnoDB中的AUTO_INCREMENT
keywords: MySQL, AUTO_INCREMENT
---

InnoDB提供了一个可配置的锁机制，改善插入AUTO_INCREMENT列的性能和扩展性。AUTO_INCREMENT的列必须可以通过类似`SELECT MAX(ai_col)`操作获取列的最大值。索引不要求必须是主键或者唯一，但是为了避免自增列重复，推荐在主键或者唯一索引上面使用AUTO_INCREMENT。

### InnoDB AUTO_INCREMENT锁模式

这一节主要介绍不同AUTO_INCREMENT锁模式如何生成自增值，并且每个锁模式对从库数据复制的影响。自增锁的模式是通过`innodb_autoinc_lock_mode`在启动时配置的。

下面一些术语用于描述`innodb_autoinc_lock_mode`的配置：
- 类插入语句

  所有语句都会数据插入新的数据行到表中,包括`INSERT`,`INSERT...SELECT`,`REPLACE`,`REPLACE...SELECT`,`LOAD DATA`。包括了简单插入，批量插入和混合模式插入。

- 简单插入
  
  在插入前就能知道插入多少的语句，包括单行和多行的INSERT和REPLACE语句，没有子查询，但是不包括`INSERT ... ON DUPLICATE KEY UPDATE`。
- 批量插入

  无法提前知道插入多少行的语句，包括了`INSERT...SELECT`,`REPLACE...SELECT`和`LOAD DATA`语句，但是不包括普通的INSERT。在处理每一行的时候，InnoDB为每一个自增列分配一个新的值。

- 混合模式插入
  
  简单插入语句中一些自增列指明的值。比如下面例子，表t1中c1是AUTO_INCREMENT的列：
  ```
  INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
  ```
  另外一种是`INSERT ... ON DUPLICATE KEY UPDATE`，在最坏的情况下，它实际上是一个INSERT后面跟着一个UPDATE，在更新阶段给自增列分配的值可能会用到也可能用不到。

`innodb_autoinc_lock_mode`有三种取值，0、1、2分别代表传统模式、连续模式和交叉模式。MySQL8.0默认为交叉模式，MySQL8.0之前模式是连续模式。

MySQL8.0默认设置为交叉模式，也反映了MySQL8.0数据复制默认从基于语句的复制到基于行的复制的改变。基于语句的复制要求连续自增的锁模式来保证分给自增列的数值是可预测的可重复的对于一组SQL语句，但是基于行的复制对于SQL的执行顺序没有要求。

- innodb_autoinc_lock_mode = 0（传统锁模式）

  传统锁模式在`innodb_autoinc_lock_mode`配置出现前就有了，传统锁模式是为了解决向后兼容，解决混合插入模式的问题等。

  在这种模式下，所有的类插入语句在插入自增列时，会获取一个特殊的AUTO-INC表级锁。这个锁被持有一直到语句执行结束（不是事务结束），以保证分配给INSERT语句的自增值是可预测的可重复的顺序，并且保证分配的自增值是连续的。

  在基于语句的数据复制模式下，保证一个SQL语句的自增列的值复制到副本服务器的时候是一样的。多个插入语句的执行结果是确定的，并且副本产生的数据与源数据库是一样的。如果多个语句的自增值是交叉的，两个并发执行的INSERT语句的结果是不确定的，基于语句的复制模式下复制到副本服务器就变得不可靠。

  通过下面的例子来说明：
  ```
  CREATE TABLE t1 (
  c1 INT(11) NOT NULL AUTO_INCREMENT,
  c2 VARCHAR(10) DEFAULT NULL,
  PRIMARY KEY (c1)
  ) ENGINE=InnoDB;
  ```
  假如有两个事务在执行，每个事务都向表中插入有自增列数据行。一个事务使用`INSERT...SELECT`语句插入1000行，另外一个使用INSERT插入一行数据：
  ```
  Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
  Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
  ```
  InnoDB无法判断Tx1的INSERT的SELECT语句会查询多少数据，它会在语句执行时每次分配一个自增值。一个表级锁被持有只到语句结束，这样表t1的INSERT语句在同一时刻只有一个能执行，并且不同语句的生成的自定数值不是交叉的。事务Tx1的`INSERT ... SELECT`生成的自增值是连续的，事务Tx2的INSERT语句生成的自增值要么大于要么小于Tx1的生成的自增值，取决于哪个语句先执行。

  在基于语句的数据复制或者在数据恢复时，二进制日志重放时SQL语句执行的顺序和原来一致，最终结果也是Tx1和Tx2第一次执行一样。因此，在基于语句的数据复制中，持有表级锁只到语句执行结束，使得INSERT语句的自增是安全的。但是，这些表级锁在多个事务同时执行INSERT语句时，会限制并发性和可扩展性。

  在前面的例子中，如果没有表级锁，事务Tx2自增列的值取决于INSERT什么时候执行。如果Tx2的INSERT是在Tx1的INSERT执行过程中执行的，那么Tx2的自增列生成的值是不确定的，可能每次执行的结果都不一样。

  在连续锁模式下，简单插入可以避免使用表级的AUTO-INC锁，由于简单插入语句插入的数据行数在执行前就是确定的，但是在基于语句复制时仍然保留了确定性和安全性。

  如果在数据恢复和复制中使用的不是重放SQL语句的方式，交叉的锁模式可以消除表级AUTO-INC锁，有更高的并发性和性能。代价是并发执行的语句可能是交叉执行的，并且自增列的值可能是不连续有间断的。

- innodb_autoinc_lock_mode = 1（连续锁模式）

  在这个模式下，批量插入会使用AUTO-INC表级锁，并且持有直到语句执行结束。 `INSERT ... SELECT`, `REPLACE ... SELECT`和`LOAD DATA`语句都是这样。同一时刻只有一个持有AUTO-INC锁的语句可以执行。如果批量插入的来源表和目标表不同，在来源表第一行获取的共享锁之后，目标表会获取AUTO-INC表级锁。如果目标表和来源表是同一个，在获取所有的查询的到行的共享锁之后才会获取AUTO-INC锁。

  简单插入（插入的行数能够提前知道）可以避免加表级AUTO-INC锁，通过加轻量级锁获取自增值，并且锁只有在分配自增值期间会持有，不是持有一直到语句执行完成。除非AUTO-INC锁被另外一个事务持有，不会加AUTO-INC表级锁。如果另外一个事务持有AUTO-INC所有，简单插入会等待AUTO-INC锁。

  这个锁模式会保证，提前无法知道具体会插入多少行的INSERT语句，所有类插入语句的自增列的值都是连续的，并且基于语句的复制是安全的。

  这个锁模式改进了可扩展性，并且基于语句的复制是安全的。有一种例外是混合模式的插入，用户给一些自增列明确指定了值，这种情况下，InnoDB会给分配自增值会比如实际插入需要的自增值更多，没有使用到自增值会被丢弃。

- innodb_autoinc_lock_mode = 2 （交叉模式）

  在这个模式下，类INSERT语句不会使用AUTO-INC锁，所以同一时刻可以执行多个语句。这是最快且最有扩展性的锁模式，但是在基于语句的复制和数据恢复数据是不安全的可能会出现不一致。

  在这个锁模式下，并发执行的类插入语句的自增值是唯一的且单调递增的。但是，由于多个语句可以在同时执行，插入行的生成的自增值可能不是连续的。

  如果执行的语句都是可以提前知道插入行数的简单插入，每个语句生成的自增值不会有间隙，除了混合模式插入。但是，对于批量插入，生成的自增值可能会有间隙。

### InnoDB自增锁模式的使用说明

- 数据复制中的自增值

  如果你使用的是基于语句的复制模式，设置`innodb_autoinc_lock_mode`为0或1，自增列的值在源数据库和副本数据库中是一致的。如果你使用的是`innodb_autoinc_lock_mode = 2`或者源数据库和副本数据库配置是不一样的，无法保证自增列的是完全一致的。

  如果你使用的基于数据行的或者混合格式的数据复制，所有的自增锁模式都是安全的，因为SQL的执行顺序对基于数据行的数据复制没有影响（并且对于那些基于基于语句的复制不安全的语句，混合格式会使用基于数据行复制）。

- 丢失自增值和数据间隙

  在所有的模式中，如果一个事务回滚，那么这个事务生成的自增值会丢弃。一旦自增值生成，就不能回滚，不管类插入语句是否执行完成，不管事务是否回滚。这些被丢弃的值不会再被使用。因此，表中自增列的数据可能是不连续的。

- 自增列的值定义为0或NULL

  在所有的模式中，如果用户在INSERT语句给自增列的值定义的是NULL或0，InnoDB认为这些行的自增列的值没有定义，会给它生成一个新的自增值。

- 自增列的值设为负值

  在所有模式中，ISNERT操作自增列的值设置为负，对于这个列自增机制的处理是未定义的。

- 如果自增的列的自增值大于整型的最大值

  在所有的模式种，如果自增值大于整型的最大值，自增行为的处理都是未定义的。

- 批量插入中自增值的间隙

  如果`innodb_autoinc_lock_mode`设置为0或1，生成的自增值都是连续的，不会有间隙，因为插入过程会获取AUTO-INC表级锁，直到批量插入语句执行结束，在同一时刻只有一个语句会执行。

  如果`innodb_autoinc_lock_mode`设置为2，批量插入生成的自增值可能会有间隙，但是只有多个类插入语句同时执行时才会如此。

  对于`innodb_autoinc_lock_mode`为1或2，多个连续的批量插入之间可能会有间隙，因为每语句需要生成的自增值的个数是不知道的，并且可能高估需要生成的自增值的个数。

- 混合模式插入的自增值

  假如有个混合模式插入的操作，为一些插入的行的自增列定义了值，一些没有定义。这样的语句在不同锁模式中处理是不同的。比如，假设表t1中c1是自增列，这个自增列当前最大的值是100。
  ```
  mysql> CREATE TABLE t1 (
    -> c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, 
    -> c2 CHAR(1)
    -> ) ENGINE = INNODB;
  ```
  现在，执行下面的混合插入模式的语句：
  ```
  mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
  ```
  `innodb_autoinc_lock_mode`设置为0，四行新数据插入结果为：
  ```
  mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
  +-----+------+
  | c1  | c2   |
  +-----+------+
  |   1 | a    |
  | 101 | b    |
  |   5 | c    |
  | 102 | d    |
  +-----+------+
  ```
  下一个自增增是103，因为自增值同时只能生成一个，不是在语句开始执行时一次生成的。无论类插入语句与是否并发执行都是这样的。

  `innodb_autoinc_lock_mode`设置为1，四行新数据插入结果为：
  ```
  mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
  +-----+------+
  | c1  | c2   |
  +-----+------+
  |   1 | a    |
  | 101 | b    |
  |   5 | c    |
  | 102 | d    |
  +-----+------+
  ```
  在这种情况下，下一个自增值是105不是103，因为四个自增值是在语句处理时生成的，但是只有两个使用了。无论类插入语句与是否并发执行都是这样的。

  `innodb_autoinc_lock_mode`设置为2，四行新数据插入结果为：
  ```
  mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
  +-----+------+
  | c1  | c2   |
  +-----+------+
  |   1 | a    |
  |   x | b    |
  |   5 | c    |
  |   y | d    |
  +-----+------+
  ```
  xy的值是唯一的且比之前的值都要大。但是xy的值取决于为并发执行语句生成的自增值的数量。

  最后考虑以下语句，自增列的最大值是100：
  ```
  mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (101,'c'), (NULL,'d');
  ```
  在任何模式下，这个语句都会产生重复key的错误，因为101被(NULL,'b')使用了，(101,'c')插入会失败。

- 在INSERT语句中修改自增列的值
  
  在MySQL5.7及以前的版本中，这会产生重复值的错误。举个例子，如果你执行了一个UPDATE操作，修改自增列的值为比当前最大自增值还要大的一个值，后面INSERT操作就可能会遇到重复数据的错误。在MySQL8.0及以后的版本中，如果你修改自增列的值为比当前最大自增值还要大的一个值，后面INSERT操作都会从这个新的最大的值开始自增。通过下面一个例子演示：
  ```
  mysql> CREATE TABLE t1 (
    -> c1 INT NOT NULL AUTO_INCREMENT,
    -> PRIMARY KEY (c1)
    ->  ) ENGINE = InnoDB;

  mysql> INSERT INTO t1 VALUES(0), (0), (3);
  
  mysql> SELECT c1 FROM t1;
  +----+
  | c1 |
  +----+
  |  1 |
  |  2 |
  |  3 |
  +----+
  
  mysql> UPDATE t1 SET c1 = 4 WHERE c1 = 1;
  
  mysql> SELECT c1 FROM t1;
  +----+
  | c1 |
  +----+
  |  2 |
  |  3 |
  |  4 |
  +----+
  
  mysql> INSERT INTO t1 VALUES(0);
  
  mysql> SELECT c1 FROM t1;
  +----+
  | c1 |
  +----+
  |  2 |
  |  3 |
  |  4 |
  |  5 |
  +----+
  ```

### InnoDB自增计数的初始化

如果在InnoDB的表中定义了一个自增列，一个内存中的表对象的自增计数被用来给新的列分配的新的自增值。

在MySQL5.7及以前的版本中，这个自增计数是保存主存中。在服务器重启后，自增计数会初始化，在插入一个自增列之前，InnoDB会执行等价与下面语句的操作。
```
SELECT MAX(ai_col) FROM table_name FOR UPDATE;
```

在MySQL8.0中，这种行为发生了改变。每次自增计数发生变化，最大的自增计数值会被写入到redo日志中，并且保存每个checkpoint的数据字典中。这样使得服务器重启之后自增计数也不会变化。
  
在MySQL服务器正常关机之后重启，InnoDB会使用数据字典中最大的自增值来初始化内存中的自增计数。

在MySQL服务器宕机恢复后重启，InnoDB会使用数据字典中最大的自增值来初始化内存中的自增计数，并且扫描redo日志中上一次的检查点写入的自增计数值。如果redo日志中记录的值比内存中的自增计数值要大，采用redo日志中的值。但是，对于服务器异常停机，重用之前生成的自增值是不能保证的。每次执行INSERT或者UPDATE操作导致自增值改变，生成的新的自增值会写入大到redo日志，但是在redo日志刷盘之前服务器异常终止，在服务器重启之后，之前生成的自增值可能会重新使用。

在导入数据时，不提供`.cfg`文件InnoDB会使用等价于`SELECT MAX(ai_col) FROM table_name FOR UPDATE`语句的操作来初始化自增计数，否则会从`.cfg `元数据文件中来读取最大的自增计数值。除此之外，使用`ALTER TABLE ... AUTO_INCREMENT = N`语句将自增计数设置为比当前保存的计数值小或者相等的值，也会使用等同于`SELECT MAX(ai_col) FROM table_name`语句的操作来确定当前最大的自增计数值。例如，可能在删除一些行之后，你可能会将计数值变小。在这种情况下，会搜索表以保证新的计数值不小于或者是等于当前的最大计数值。

在MySQL5.7及以前的版本，在`CREATE TABLE`或者`ALTER TABLE`通过`AUTO_INCREMENT = N`设置或者修改自增计数的值，在服务器重启之后会失去效果。在MySQL8.0中，重启之后不会使`AUTO_INCREMENT = N`失效。
> **注意**
> 
> `ALTER TABLE ... AUTO_INCREMENT = N`只能修改自增计数值为一个比当前最大计数值大的值。

在MySQL5.7及以前的版本，在一个回滚事务之后重启MySQL服务器，会导致为回滚事务生成的自增值被重新使用。在MySQL8.0中，因为最大的自增值已经保存在磁盘中，所以不会出现这种问题。

在自增计数初始化后，如果你在插入数据得不明确为自增列指定值，InnoDB会隐式为自增计数值为新插入的行生成一个自增值。如果你插入时为自增列明确指定一个值，并且这个值比最大的自增计数大，计数值被设置为这个指定的值。

`auto_increment_offset`设置AUTO_INCREMENT列的初始值，默认设置值是1。

`auto_increment_increment`控制自增列的每次自增的增长值，默认设置为1。

**注意**

当自增列的整型值用完时，后面的插入操作会出现重复值错误，这是MySQL的一般处理行为。





