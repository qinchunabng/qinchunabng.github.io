---
layout: post
title: InnoDB结构
categories: [MySQL]
description: InnoDB结构
keywords: MySQL, InnoDB
---

## InnoDB结构

![InnoDB架构图](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/mysql/innodb-architecture-8-0.png)

## InnoDB内存结构

### 缓存池

缓存池是主存中用来缓存InnoDB所访问表和索引数据的内存区域。缓存池会缓存经常访问的数，这样这些数据就不需要进行磁盘I/O。在专用服务器上，高达80%的内存分配给缓存池。

为了大容量读操作效率，缓存池会被分成可以容量多行数据的页。为了提供缓存的管理效率，缓存池的页之间是通过链表进行关联的，并且使用LRU算法对旧数据进行处理。

了解如何利用缓存池的将经常访问的数据留在内存中，是MySQL优化的一个重要方面。

### 缓存池的LRU算法

缓存池用的是LRU算法的变种，当需要往缓存池插入新的页时，最近最少使用的页会被回收，新的页会被添加页链表的中间，这个中间点把链表分为两个部分：
- 中间点的前面一部分，是最近访问过的页
- 中间点的后面一部分，是最近访问比较少的页
  
![缓存池链表](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/mysql/innodb-buffer-pool-list.png)

这个算法将经常被访问的页放到新子链表中，旧的子链表中放访问较少的页，这些页可能会被淘汰回收。
默认情况，这个算法的操作如下：
- 缓存池的3/8是旧的子链表。
- 链表的中间点在新的子链表的尾部，在旧子链表的头部，是新旧的分割点。
- 访问旧子表中的页，会使这个页移动到新子表的头部。如果读取页是用户发起的操作，这个页被置为年轻页，如果读取页是预读操作而读取的则不会。
- 缓存池中没有被访问的页会主键移动到链表的尾部，最终旧的子列表中没有被访问的页会被淘汰回收。
  
默认情况下，被查询操作读取页会被直接放到新的子列表中，这意味着这些数据会在缓冲池停留更长的时间。像mysqldump的操作和不带查询的条件的SELECT这样会导致全表扫描的操作，会将大量的数据放进新子列表中，并淘汰一些旧的数据给新加入的数据腾空间，即使这些数据只访问了一次。类似的，后台预读线程加载的只读取一次的页，也会被放到新的子列表中。这些情况下，会导致一些经常被访问的页被淘汰回收。

### 更新缓冲区

更新缓存是一个特殊的数据结构，当二级索引页不在缓存池中时，将二级索引的变更缓存起来。这些变更都是INSERT,UPDATE和DELETE这样的DML操作导致的，在后面读操作把数据页加载到缓冲池之后会被合并。

![更新缓存](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/mysql/innodb-change-buffer.png)

不像聚簇索引，二级索引不是唯一的，并且二级索引的数据的插入是以相对随机的顺序进行的。同样的，删除和更新操作可能影响的到二级索引页中不相邻的数据。当其他操作读取被影响的数据到缓存池之后，会合并更新缓存的内容，避免从硬盘将二级索引页读到缓冲池而引起的随机I/O。

在系统空闲的或者关机时，清理操作会将更新的索引页周期性的写入到硬盘中，这种方式比每次执行写操作都写入硬盘要高效的多。

当有大量受影响行和二级索引数据更新时，变更缓存合并可能会花费几个小时。这期间硬盘I/O增加，会影响其他的硬盘读操作。更新缓存合并也可能会在事务提交后或者服务器重启之后发送。

在内存中，更新缓存占用了一部分缓存池。在硬盘中，变更缓存时系统表空间的一部分，当数据库服务器关机时来缓存索引变更。

如果二级索引或者主键包含降序索引列，二级索引不支持更新缓存。

### 配置更新缓冲区

当执行INSERT,UPDATE和DELETE操作，被更新索引列的值（特别是二级索引的）经常都是无序的，需要I/O操作来更新二级索引。更新缓冲区缓存了二级索引的数据，当相关数据也不在缓冲池中，来避免直接从硬盘读数据这样昂贵的I/O操作。缓存的更新在相关数据页加载到缓存池的时候会被合并，更新的页稍后会刷新到硬盘上。InnoDB的主线程会在服务器空闲或者关闭的时候合并更新的缓存。

对于DML这样的会写操作，开启更新缓冲区是很有必要的，能够减少磁盘I/O。

但是更新缓冲区会占用一部分缓存池的内存，减少用来缓存数据页的内存大小。如果缓存池的大小能够缓存的下查询数据，或者你的表只有少量的二级索引，可以关闭更新缓冲区。如果缓存池能够一直容得下所有的查询数据，更新缓冲区不会带来额外的开销，因为更新缓冲器只会在数据页不在缓冲池的时候才会被使用到。

通过`innodb_change_buffering`配置可以设置更新缓冲区对InnoDB的哪些操作生效，