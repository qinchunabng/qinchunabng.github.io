---
layout: post
title: MySQL InnoDB中的幻读
categories: [MySQL]
description: MySQL InnoDB中的幻读
keywords: 数据库, MySQL, InnoDB, 幻读
---

幻读就是同一个事务中执行同样的查询返回的结果集不一样。例如：在一个事务中一个SELECT执行了两次，第二次查询返回的数据跟第一次不一样，这样的数据行就叫幻行。

假设有一张child表，child表有id字段并且id列有索引，你想要查询并id>100的数据，然后更新这些数据的某些列：
```
SELECT * FROM child WHERE id > 100 FOR UPDATE;
```
查询会扫描索引，从id>100的索引记录开始扫描。表中有id为90和102的数据，假如只会给扫描返回的索引记录加锁，并不会阻塞其他事务在数据间隙中插入数据，另外一个会话插入一行id为101数据行。如果你在同一个事务再次执行同样的SELECT语句，你会查询到新的一行id为101的数据。这就违反了同一个事务中读取的数据应该一致的原则。

为了阻止幻读，InnoDB采用结合记录锁和间隙锁的next-key锁。InnoDB执行行级锁的逻辑是，在查询扫描索引过程中，给扫描到的索引记录加上共享或者独占锁。因此行级锁实际上就是索引记录锁。此外，next-key锁除了会锁定一个索引记录，还会锁定索引记录前的间隙。即next-key是一个索引记录锁加上一个索引记录前的间隙锁。如果一个会话在一个索引记录R上设置有共享或者独占锁，其他会话无法直接插入一行数据到索引记录前的间隙中。

当InnoDB扫描索引时，也会锁定最后一个记录后的数据间隙。还是以上面一个例子为例：为了阻止插入id>100的数据到表中，也会给id>102的数据间隙加上锁。

你可以使用next-key锁来实现数据的唯一检查：如果你通过共享锁来读取数据，查询之后发现没有你要插入的数据，这时就可以安心的插入这行数据。因为next-key锁会在你读取时候时候会锁定数据来防止其他事务插入这行数据导致重复。因此next-key锁可以锁定一些表中并不存在的数据。

