---
layout: post
title: MySQL InnoDB的锁
categories: [MySQL]
description: MySQL InnoDB的锁介绍
keywords: 数据库, MySQL, InnoDB, 锁
---

MySQL的InnoDB中有多种锁，InnoDB在不同的操作和事务隔离级别使用这些锁，来保证数据的一致性。

#### 共享锁和独占锁

InnoDB实现了共享锁和独占锁两种行级锁。

- 在事务中读取一行数据的时候会加共享(S)锁。

- 在事务中更新或者删除一行的时候会加独占(X)锁。

如果事务T1持有数据行r的S锁，另一个事务T2对数据行r的锁申请处理如下：

- 如果事务T2是申请加S锁，可以加锁成功，事务T1和T2同时持有数据行r的S锁。

- 如果事务T2是获取的X锁，则无法获取X锁。

如果事务T1获取的是X锁，则事务T2无论是获取S锁和X锁都无法获取成功，事务T2需要等到事务T1释放锁才能获取锁。
#### 意向锁

意向锁是表级锁，表明事务稍后会申请对数据行的共享或独占锁。InnoDB中又两种意向锁：

- 意向共享(IS)锁，表示一个事务准备给表中的数据加共享锁。

- 意向独占(IX)锁，标识一个事务准备给表中的数据加独占锁。

例如：`SELECT...FOR SHARE`会设置意向共享锁，`SELECT...FOR UPDATE`会设置意向独占锁。

意向锁的加锁规则如下：

- 一个事务在获取一行数据的共享锁之前，必须先获取IS锁或者更强的锁。

- 一个事务在获取一行数据的独占锁之前，必须先获取IX锁。

意向锁与共享锁独占锁的兼容性如下表所示：

||X|IX|S|IS|
|:---|:---:|---:|---:|---:|
|X|冲突|冲突|冲突|冲突|
|IX|冲突|兼容|冲突|兼容|
|S|冲突|冲突|兼容|兼容|
|IS|冲突|兼容|兼容|兼容|

如果一个事务的锁请求与当前已存在的锁兼容，那么这个事务获取锁成功，否则无法获取到锁，需要等到锁释放之后才能获取锁。因为冲突的锁之间可能会导致思索。意向锁除了整表请求（例如：`LOCK TABLES...WRITE`）不会锁任何东西，意向锁的主要目的是表明将要锁某一行数据或者某一行数据已经加锁。

#### 记录锁

记录锁是索引记录上的锁。例如:`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;`会阻止其他事务插入、更新和删除t.c1=10的数据行。记录锁需要通过索引来加锁，如果一个表没有索引，InnoDB会创建一个隐藏的聚集索引来加记录锁。

#### 间隙锁

间隙锁是索引记录之间间隙的锁，或者说是第一个索引记录之前或最后一个索引记录之后的间隙锁。例如：`SELECT t1 FROM t WHERE c1 BETWEEN 10 AND 20 FOR UPDATE;`会阻止其他事务插入t.c1=15的数据行到表中，无论表中是否已经有该数据都会阻止，因为10到20之间的间隙已经加锁。

间隙锁是性能和并发之间的一个权衡，InnoDB中一些事务隔离级别会用到间隙锁。

使用唯一索引作为条件查询的SQL语句不会加间隙锁（不包含多列唯一索引的情况）。例如，下面的SQL语句中，如果id是唯一索引，只会给id等于10的记录加记录锁，不会阻止其他会话插入间隙内的数据。

```
SELECT * FROM child WHERE id=100;
```
如果id不是一个索引或者不是唯一索引，会锁住的间隙。

另外需要注意的是不同事务之间的间隙锁可以同时存在。例如在一个间隙上，事务A持有共享间隙锁，同时事务B可以持有独占间隙锁。间隙锁存在的目的仅仅是阻止其他事务插入数据到间隙，一个间隙锁不会阻止其他事务在相同间隙加锁，共享间隙锁和独占间隙锁没有区别。

设置事务隔离级别为`READ_COMMITED`，会关闭间隙锁，这个时候间隙锁只会用来做外键检查约束和重复值检查。另外，MySQL在评估where查询条件后会失败不匹配的记录锁。对于UPDATE语句，InnoDB采用的是半一致性读，UPDATE语句会返回最新提交事务的数据，这样MySQL可以确定WHERE条件是否符合。

#### Next-Key锁

Next-Key锁是记录锁和间隙锁的结合。InnoDB加行锁是在查询或扫描索引的过程，将扫描的索引记录加上共享锁或者独占锁。所以行锁实际是索引记录锁。Next-Key锁是索引记录锁加索引记录间的间隙锁，如果一个会话在一个索引记录行R上又共享或者独占锁，另外一个会话是不能在R之前索引顺序的间隙中插入一条新的记录。

假设一个索引包含索引值10，11，13和20，next-key锁的锁定的范围如下（圆括号不包含索引行，方括号包含）：
```
(-∞,10]
(10,11]
(11,13]
(13,20]
(20,+∞)
```
对于最后一个索引范围，next-key锁会锁定最大值之后的索引间隙。

InnoDB默认使用的是`REPEATABLE_READ`事务隔离级别，对于查询和索引扫描会使用next-key锁，来防止幻读。

#### 插入意向锁

插入意向锁是一种间隙锁，在插入之前之前获取。如果在多个事务中插入的数据是同一个间隙的不同一个位置，事务直接不会相互阻塞。假如一个索引记录有值为4和7的数据，有两个不同的事务分别准备插入5和6，在获取插入行的独占锁之前，分别先要获取4到7的插入意向锁，这两个事务之间不会相互阻塞。

下面的例子展示两个不同的事务在插入数据行之前获取插入意向锁。先创建一个表包含两个索引记录（90和102），然后执行一个事务A，在id大于100的索引记录上加上独占锁，这个独占锁包含了一个102之前的间隙锁。

```
mysql> CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;
mysql> INSERT INTO child (id) values (90),(102);

mysql> START TRANSACTION;
mysql> SELECT * FROM child WHERE id > 100 FOR UPDATE;
+-----+
| id  |
+-----+
| 102 |
+-----+
```

然后再执行一个事务B，在数据间隙中插入一行记录，这个事务将等待获取独占锁之前先会加一个插入意向锁。
```
mysql> START TRANSACTION;
mysql> INSERT INTO child (id) VALUES (101);
```

#### 自增锁

自增锁是特殊的表级锁，当一个表有自增列，插入数据时会加自增锁。当一个事务插入数据时，其他事务必须等待这个事务获取到一个连续不间断的主键值才能执行插入。innodb_autoinc_lock_mode参数可以选择自增锁的算法，通过这个参数可以调整自增序列可预测性和最大并发数之间等级。