---
layout: post
title: GO协程
categories: [GO]
description: GO协程
keywords: GO
---

## GO协程

什么是协程？先看一下一段栗子：
```
package main

import (
	"fmt"
	"time"
)

func say(s string) {
	for i := 0; i < 5; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)
	}
}

func main() {
	go say("world")
	say("hello")
}
```

在GO语言中通过关键字go启动一个协程，`go say("world")`会在一个新启动的协程中执行，不会阻塞主执行流程。通过协程（GOROUTINES）处理一些耗时的操作，使程序并行执行，提高执行效率。

## 协程与线程的区别

在其他语言中（比如java），要使代码并行执行，是通过线程完成。将需要并行执行的代码放到一个线程中，那么线程与协程有什么区别？

明白线程与协程的区别，我们先要了解内核级线程和用户级线程概念。用户级线程只存在用户态中，对它的创建、撤销和切换不通过系统调用来实现，内核并不知道用户级线程的存在。用户级线程是运行在运行时系统中，由运行时系统进行管理，运行时系统就是语言的运行环境。在每个进程中都有自己的线程表，用来跟踪进程中线程。由于线程切换不需要内核的参与，不需要上下文切换，也不需要对内存高速缓存进行刷新，就是使得用户级线程调度非常快。

内核线程依赖内核，它们的创建、撤销和切换都由内核实现。在内核中有一个线程控制块，系统根据线程控制块感知到线程的存在堆线程进行控制。当某个线程需要创建一个新线程或者撤销一个线程，会执行一个系统调用，这个系统调用同通过对线程表的更新完成线程的创建或撤销。

![用户级线程与内核级线程对比示意图](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/go/%E7%BA%BF%E7%A8%8B.png)

用户级线程与内核级线程相比，主要有以下几个区别：

- 用户级线程切换不需要内核的参与，所以切换速度会比内核级线程快很多。

- 当传统的用户进程调用一个系统调用时，会从用户态转入内核态，用户进程将被封锁。知道系统调用完成时，才将该进程唤醒继续执行。所以在用户级线程调用一个系统调用时，由于内核并不知道用户级线程的存在，因而把系统调用看作整个进程的行为，于是该进程出现等待，系统调用另外一个进程执行。如果系统设置的是内核级线程，则调度是以线程为单位。当一个线程调用系统调用时，只会阻塞调用线程，仍然可以调度进程中的其他线程执行。

- 如果系统设置的是用户级线程，调度以进程为单位进行的。在才有轮转调度算法时，各个进程轮流执行一个时间片，对进程而言似乎是公平的。但是如果进程A中只有一个用户级线程，而进程B中有100个用户级线程，那么进程A中线程的运行时间就是进程B的100倍。如果系统设置的是内核级线程，其调度是以线程为单位，这样的话进程B获得处理器的时间是进程A的100倍。

结合用户级线程和内核级线程的优缺点，就出现了混合实现的方式。混合实现的方式就是内核级线程和用户级线程同时使用，一个内核级线程被多个用户级线程多路复用。当一个用户级线程被阻塞时，转而去执行其他的用户级线程，这样一个内核级线程就可以被多个用户级线程轮流使用。这种内核级线程和用户级线程混合使用的方式就是协程。
