---
layout: post
title: GO协程
categories: [GO]
description: GO协程
keywords: GO
---

## GO协程

什么是协程？先看一段栗子：
```
package main

import (
	"fmt"
	"time"
)

func say(s string) {
	for i := 0; i < 5; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)
	}
}

func main() {
	go say("world")
	say("hello")
}
```

在GO语言中通过关键字go启动一个协程，`go say("world")`会在一个新启动的协程中执行，不会阻塞主执行流程。通过协程（GOROUTINES）处理一些耗时的操作，使程序并行执行，提高执行效率。

## 协程与线程的区别

在其他语言中（比如java），要使代码并行执行，是通过线程完成。将需要并行执行的代码放到一个线程中，那么线程与协程有什么区别？

明白线程与协程的区别，我们先要了解内核级线程和用户级线程概念。用户级线程只存在用户态中，对它的创建、撤销和切换不通过系统调用来实现，内核并不知道用户级线程的存在。用户级线程是运行在运行时系统中，由运行时系统进行管理，运行时系统就是语言的运行环境。在每个进程中都有自己的线程表，用来跟踪进程中线程。由于线程切换不需要内核的参与，不需要上下文切换，也不需要对内存高速缓存进行刷新，就使得用户级线程调度非常快。

内核线程依赖内核，它们的创建、撤销和切换都由内核实现。在内核中有一个线程控制块，系统根据线程控制块感知到线程的存在堆线程进行控制。当某个线程需要创建一个新线程或者撤销一个线程，会执行一个系统调用，这个系统调用通过对线程表的更新完成线程的创建或撤销。

![用户级线程与内核级线程对比示意图](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/go/%E7%BA%BF%E7%A8%8B.png?raw=true)

用户级线程与内核级线程相比，主要有以下几个区别：

- 用户级线程切换不需要内核的参与，所以切换速度会比内核级线程快很多。

- 当传统的用户进程调用一个系统调用时，会从用户态转入内核态，用户进程将被封锁。直到系统调用完成时，才将该进程唤醒继续执行。所以在用户级线程调用一个系统调用时，由于内核并不知道用户级线程的存在，因而把系统调用看作整个进程的行为，于是该进程出现等待，系统调用另外一个进程执行。如果系统设置的是内核级线程，则调度是以线程为单位。当一个线程调用系统调用时，只会阻塞调用线程，仍然可以调度进程中的其他线程执行。

- 如果系统设置的是用户级线程，调度以进程为单位进行的。在使用轮转调度算法时，各个进程轮流执行一个时间片，对进程而言似乎是公平的。但是如果进程A中只有一个用户级线程，而进程B中有100个用户级线程，那么进程A中线程的运行时间就是进程B的100倍。如果系统设置的是内核级线程，其调度是以线程为单位，这样的话进程B获得处理器的时间是进程A的100倍。

结合用户级线程和内核级线程的优缺点，就出现了混合实现的方式。混合实现的方式就是内核级线程和用户级线程同时使用，一个内核级线程被多个用户级线程多路复用。当一个用户级线程被阻塞时，转而去执行其他的用户级线程，这样一个内核级线程就可以被多个用户级线程轮流使用。这种内核级线程和用户级线程混合使用的方式就是协程。

简单的说，就是内核级线程创建、销毁和切换比较麻烦。用户级线程比较轻量，创建、销毁和切换比内核级线程快。但是用户级线程无法发挥多核CPU的性能，所以结合用户级线程核和内核级线程的有点，就出现两种方式结合使用的协程。

## GOROUTINE的工作原理

GOROUTINE的调度是GO语言运行时实现的调度系统go scheduler进行调度的，采用的是GPM调度模型。

![GPM](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/go/gpm.png?raw=true)

- G: 代表goroutine，每执行一次go f()就创建一个G，包含需要执行的和上下文信息。
- 全局队列: 存放等待执行的G。
- P: 代表goroutine执行所需的资源，最多有GOMAXPROCS个。
- P的本地队列：同全局队列类似，存放的也是等待执行的G，存放的数量有限，不超过256个。新建G时，优先存放到本地队列中，如果本地队列满了再存放到全局队列中。
- M: M代表一个内核级线程，M要执行任务，必须获取P，从P的本地队列中获取G，当本地队列为空时，M会尝试从全局队列或者从其他P的本地队列中尝试获取G。M执行完一个G之后，会从队列中获取下一个G，不断重复。
  
goroutine是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度内核线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。