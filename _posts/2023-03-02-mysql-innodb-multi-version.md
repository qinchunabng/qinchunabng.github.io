---
layout: post
title: MySQL InnoDB的多版本
categories: [MySQL]
description: MySQL InnoDB的多版本
keywords: 数据库, MySQL, InnoDB
---

### InnoDB的多版本

InnoDB是一个多版本的存储引擎，它会保存数据行的旧版本以支持并发和回滚事务特性。这些信息被保存在undo表空间的称为回滚段的数据结构中。InnoDB使用回滚段中的这些信息来执行事务回滚的undo操作，也可以用来构建旧版本数据来实现[一致性读](https://qinchunabng.github.io/2023/03/01/mysql-innodb-consistent-nonblocking-read/)。

InnoDB给每行数据添加三个字段存储在数据库中：
- 一个6字节的DB_TRX_ID字段，表示最近更新或者插入这行数据的唯一标识。删除也被当作为修改操作，数据行中一个特定的比特位标识数据是否被删除。
- 一个7字节的DB_ROLL_PTR字段，也叫做回滚指针。回滚指针指向回滚段中的一个undo日志记录，undo日志记录包含重建被更新前的数据行的必要信息。
- 一个6字节DB_ROW_ID字段，包含一个row ID，这个row ID在插入数据的数据的时候单调递增。如果由InnoDB生成聚集索引，索引中才会包含row ID，否则不会包含。

回滚段中undo日志分为插入和更新undo日志。插入undo日志只在回滚的时候需要，在事务提交后马上被删除。update的undo日志在一致性读也会用到，但是在当前没有需要update undo日志来构建旧版的数据事务存在时，update undo日志也会被删除。

所以建议一定要提交事务，即使事务中只包括一致性读。否则，InnoDB不会删除update undo日志，回滚段会增长的很大，占满undo表空间。
另外一个undo日志记录是要比对应插入或者更新数据要小的。

在InnoDB多版本机制中，通过DELETE语句删除的数据并不会立即被物理删除。InnoDB只会在DELETE操作的更新undo日志被丢弃的时候才物理删除对应的数据行和索引记录。删除操作非常快，一般在DELETE语句执行后马上就删除了。

如果你以相同的速度批量插入和删除数据，清理线程会延后，并且表会变得越来越大，使所有的内容都受到磁盘的限制而变得很慢。这种情况下，就不要在执行新的操作了，并且通过调整innodb_max_purge_lag系统变量给清理线程更多资源。

### 多版本和二级索引

InnoDB多版本并发控制(MVCC)对待二级索引与聚簇索引是不一样的。聚集索引中的记录是就地更新，并且他们的隐含的系统列会指向undo日志条目。不像聚簇索引记录，二级索引记录不包含隐藏的系统列，也不会原地更新。

当一个二级索引列被更新，旧的二级索引记录会被标记为删除，新的记录会被插入，标记为删除的记录最终会被清理。当二级索引记录被删除或二级索引页被后面的事务更新时，InnoDB在聚集索引中查找该数据库记录。在聚集索引中，检查记录的DB_TRX_ID，如果记录在读取事务启动后被修改，则从undo日志中检索该记录的正确版本。并且在这种情况下，覆盖索引是不会被使用到，InnoDB会通过回表从聚簇索引获取数据。

但是，如果启用了索引条件下推(ICP)优化，并且WHERE条件的某些部分只能使用索引中的字段进行计算，MySQL服务器仍然会将WHERE条件的这一部分下推到存储引擎，在存储引擎中使用索引进行计算。如果没有找到匹配的记录，则避免进行聚集索引查找。如果找到了匹配的记录，即使是在删除标记的记录中，InnoDB也会在聚集索引中查找该记录。