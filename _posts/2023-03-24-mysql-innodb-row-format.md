---
layout: post
title: InnoDB行格式
categories: [MySQL]
description: InnoDB行格式
keywords: MySQL, InnoDB
---

### InnDB行格式

表的行格式决定了如何物理存储数据行，数据的物理存储方式会影响查询和DML操作的性能。一个磁盘页的存储的数据行越多，查询和索引查找越快，需要的缓冲池越小，更新操作的I/O越少。

表中的数据分散存储在数据页中，组成表的数据页是按照B树的结构组织起来的，表数据和二级索引都是使用这种数据结构。代表整个表的B树索引就是聚簇索引，是按照主键列组织的。聚簇索引的节点包含了整个行的所有数据。二级索引包含的索引列的值和主键列的值。

除了可变长度的列，列值都是存储在B树索引节点中。可变长度的列太大，不适合放在B树的数据页中，所以是单独存储在单独分配的磁盘页，这种数据页叫做溢出页。这样的列称为离页列，离页列的值存储在由溢出页组成的单链表中，每个这样的列都有一个或多个溢出页的列表。根据列的长度，将整个列或者可变长度的列的前缀存储在B树种，避免浪费存储空间以及从其他数据页读取数据。

InnoDB存储引擎支持四种行格式：REDUNDANT,COMPACT,DYNAMIC和COMPRESSED。

### REDUNDANT行格式

REDUNDANT行格式提供旧版本MySQL的兼容性。

使用REDUNDANT行格式的表使用B树节点索引记录的前768字节存储可变长度的列值（VARCHAR,VARBINARY,BLOB和TEXT类型），剩余的部分存在溢出页中。大于或等于768字节的固定长度的列编码成可变长度的列，超过长度的数据存在其他的页。例如，一个使用utf8mb4字符集的CHAR(255)的列大小会超过768字节，因为utf8mb4字符集的一个字符为3个字节。

如果一个列的值少于等于768字节，不会使用溢出页，并且会节省一些I/O，因为列的值都是存储B树节点中。小的BLOB列值也是如此，但是可能会导致B书节点被行数据占满，而不是索引的key值，减小了索引的效率。包含BLOB列的表可能会导致B树节点被BLOB列占用，导致每个节点包含的数据行变少，使得整个索引比数据行小的更低效，或者导致列值会分开存储在其他页中。

#### REDUNDANT行格式存储特性

REDUNDANT有如下存储特性：

- 每个索引记录包含6字节的header，这个header用来将连续的记录关联起来，同时也用作行级锁。
- 聚簇索引中的记录包含所有用户定义的列字段。另外，还包含6字节的事务ID字段和7字节的回滚指针字段。
- 如果表没有定义主键，每个聚簇索引记录会包含一个6字节的行ID字段。
- 每个二级索引都会包含对应主键索引的key值。
- 每个记录都包含一个指向记录中各个字段的指针。如果记录中字段的总长度小于128字节，指针为1个字节；否则，为2个字节。这些指针组成的数据称为记录目录。这些指针指向的区域就是记录的数据部分。
- 像CHAR(10)这样的固定长度的列是按照固定长度格式存储的。VARCHAR列尾部的空格部分不会被截断。
- 大于等于768字节的固定长度的列也会向可变长度的列一样处理，会被分开存储到单独的页中。例如，一个使用utf8mb4字符集的类型为CHAR(255)列会超过768字节，因为utf8mb4字符集中一个字符占3字节。
- NULL值会占用记录目录的1或2个字节空间。可变长度的列中，NULL值在记录的数据部分中占用0个字节。而对于固定长度的列，NULL值仍然会在记录的数据部分占用固定长度的大小，这样的话如果将NULL值更新为非NULL的值，就不会产生索引页的碎片。

### COMPACT行格式