---
layout: post
title: InnoDB行格式
categories: [MySQL]
description: InnoDB行格式
keywords: MySQL, InnoDB
---

### InnDB行格式

表的行格式决定了如何物理存储数据行，数据的物理存储方式会影响查询和DML操作的性能。一个磁盘页的存储的数据行越多，查询和索引查找越快，需要的缓冲池越小，更新操作的I/O越少。

表中的数据分散存储在数据页中，组成表的数据页是按照B树的结构组织起来的，表数据和二级索引都是使用这种数据结构。代表整个表的B树索引就是聚簇索引，是按照主键列组织的。聚簇索引的节点包含了整个行的所有数据。二级索引包含的索引列的值和主键列的值。

除了可变长度的列，列值都是存储在B树索引节点中。可变长度的列太大，不适合放在B树的数据页中，所以是单独存储在单独分配的磁盘页，这种数据页叫做溢出页。这样的列称为离页列，离页列的值存储在由溢出页组成的单链表中，每个这样的列都有一个或多个溢出页的列表。根据列的长度，将整个列或者可变长度的列的前缀存储在B树种，避免浪费存储空间以及从其他数据页读取数据。

InnoDB存储引擎支持四种行格式：REDUNDANT,COMPACT,DYNAMIC和COMPRESSED。

### REDUNDANT行格式

REDUNDANT行格式提供旧版本MySQL的兼容性。

使用REDUNDANT行格式的表，可变长度的列（VARCHAR,VARBINARY,BLOB和TEXT类型）的前768字节存放在索引的B数节点中，剩余的部分存在溢出页中。固定长度的列大于等于768字节，也是和可变长度的列一样，超过768字节的数据存在单独的页。

如果一个列的值少于等于768字节，不会使用溢出页，并且会节省一些I/O，因为列的值都是存储B树节点中。小的BLOB列值也是如此，但是可能会导致B书节点被行数据占满，而不是索引的key值，减小了索引的效率。包含BLOB列的表可能会导致B树节点被BLOB列占用，导致每个节点包含的数据行变少，使得整个索引比数据行小的更低效，或者导致列值会分开存储在其他页中。

#### REDUNDANT行格式存储特性

REDUNDANT有如下存储特性：

- 每个索引记录包含6字节的header，这个header用来将连续的记录关联起来，同时也用作行级锁。
- 聚簇索引中的记录包含所有用户定义的列字段。另外，还包含6字节的事务ID字段和7字节的回滚指针字段。
- 如果表没有定义主键，每个聚簇索引记录会包含一个6字节的行ID字段。
- 每个二级索引都会包含对应主键索引的key值。
- 每个记录都包含一个指向记录中各个字段的指针。如果记录中字段的总长度小于128字节，指针为1个字节；否则，为2个字节。这些指针组成的数据称为记录目录。这些指针指向的区域就是记录的数据部分。
- 像CHAR(10)这样的固定长度的列是按照固定长度格式存储的。VARCHAR列尾部的空格部分不会被截断。
- 大于等于768字节的固定长度的列也会向可变长度的列一样处理，会被分开存储到单独的页中。例如，一个使用utf8mb4字符集的类型为CHAR(255)列会超过768字节，因为utf8mb4字符集中一个字符占3字节。
- NULL值会占用记录目录的1或2个字节空间。可变长度的列中，NULL值在记录的数据部分中占用0个字节。而对于固定长度的列，NULL值仍然会在记录的数据部分占用固定长度的大小，这样的话如果将NULL值更新为非NULL的值，就不会产生索引页的碎片。

### COMPACT行格式

COMPACT行格式相比REDUNDANT行格式减少了20%行存储空间，代价是会增加部分操作的CPU消耗。如果你的操作性能受限于缓存命中率和磁盘速度，COMPACT格式可能会更快。如果操作主要消耗的CPU,COMPACT格式可能会较慢。

使用COMPACT行格式的表，可变长度的列（VARCHAR,VARBINARY,BLOB和TEXT类型）的前768字节存放在索引的B数节点中，剩余的部分存在溢出页中。固定长度的列大于等于768字节，也是和可变长度的列一样，超过768字节的数据存在单独的页。例如，一个使用utf8mb4字符集的CHAR(255)的列大小会超过768字节，因为utf8mb4字符集的一个字符为3个字节。

如果一个列的值少于等于768字节，不会使用溢出页，并且会节省一些I/O，因为列的值都是存储B树节点中。小的BLOB列值也是如此，但是可能会导致B书节点被行数据占满，而不是索引的key值，减小了索引的效率。包含BLOB列的表可能会导致B树节点被BLOB列占用，导致每个节点包含的数据行变少，使得整个索引比数据行小的更低效，或者导致列值会分开存储在其他页中。

#### COMPACT行格式存储特性

COMPACT行格式有如下存储特性：

- 每个索引记录都包含5字节的header，这个header前面可能还有一个可变长度的header。这个header是用来将记录串连起来，在加行级锁的时候也会使用到。
- 记录头部的可变长度部分包含一个位向量，用来标识NULL列。如果可为NULL的列为N个，那么位向量占用CEILING(N/8)字节。（例如，如果有9到16个列都是可为NULL的列，这个位向量占用2个字节。）为NULL的列除了占用这个位向量的1bit空间外，不会再占用其他空间。header的变长部分也包含了可变长度列的长度。每个长度占用1到2个字节，取决于列的最大长度。如果所有的列都是非空的，且都是固定长度，那么记录的header就没有可变长度部分。
- 对于每个非NULL可变长度的字段，记录头包含1或2个字节来表示字段的长度。只有列需要外部页存储数据，或者列的最大大小超过255字节且实际大小超过127字节，需要2个字节来表示字段的长度。对于需要外部存储的列，2字节表示列的实际大小为内部存储的长度加上20字节指针指向的外部存储数据的大小，所以外部存储的列索引记录占用768+20字节大小的空间。
- 记录头后面就是非NULL列的数据内容。
- 聚簇索引的记录包含表中定义的所有的列。另外，还有6字节的事务ID和7字节的回滚指针字段。
- 如果表没有定义主键，聚簇索引记录中会包含一个6字节的行ID字段。
- 每个二级索引记录会包含一个主键值。如果主键列是变长的，每个二级索引记录头都有一个变长的部分来记录主键列的长度，即使二级索引是固定长度的列。
- 对于非变长字符集，像CHAR(10)固定长度的列是按照固定长度的格式存储的。VARCHAR的列尾部的空白字符不会被截断。
- 对于utf8mb3和utf8mb4这样的变长的字符集，对于CHAR(N)这样的列InnoDB会通过阶段尾部空白字符的方式尝试用N字节存储列值。如果一个CHAR(N)列的值超过N字节，尾部的空白字符会截取来减小列的大小。一个CHAR(N)列最大长度为字符集最大的字符长度 * N。
  CHAR(N)的列最少会占用N个字节。使用最小的N字节在很多情况下可以避免更新操作产生索引碎片。对比REDUNDANT格式，CHAR(N)会占用字符集最大字符长度 * N大小的空间。

### DYNAMIC行格式

DYNAMIC行格式提供了与COMPACT行格式一样的存储特性，但是优化了长的变量列的存储方式，并且支持大的索引前缀。

如果一个表使用DYNAMIC行格式创建，InnoDB会将过长的变长列的值（如VARCHAR,VARBINARY,BLOB和TEXT类型）全部存储在单独的溢出页，聚簇所以你记录中只包含一个20字节大小的指向外部溢出页的指针。大于等于768字节的固定长度的字段存储方式也是如此。如果，如果一个CHAR(255)的列，使用的是utf8mb4字符集，列的大小就会超过768字节。

列是否存储到索引页外部的页中，取决于页的大小和行的总大小。如果行数据太大，最大列会存储到外部的页中，以便B树的页能够容得下聚簇索引的记录。小于或等于TEXT和BLOB字段也是存储在聚簇索引页中。

和COMPACT,REDUNDANT行格式一样，DYNAMIC行格式也是尽可能将整行数据存储在索引节点中，但是DYNAMIC行格式会避免长度很大的列的数据占满B数据节点。DYNAMIC行格式的原则是，如果列的部分数据会存储到外部页中，那么就会把整个列的数据都存放在外部页。DYNAMIC行格式中，B数据节点中都是保存较短的列，这样来减少对外部页的需要。

DYNAMIC行格式支持最大3072字节索引前缀。

#### DYNAMIC行格式存储特性

DYNAMIC行格式时COMPACT行格式的变种，所以存储特性是一样的。

### COMPRESSED行格式

COMPRESSED行格式的存储特性和功能与DYNAMIC一样，添加了对表和索引数据压缩的支持。

COMPRESSED行格式分页存储内部实现与DYNAMIC行格式的一样，由于表和索引数据被压缩并使用更小的页，因此需要考虑额外的存储和性能消耗。在COMPRESSED行格式种，通过KEY_BLOCK_SIZE属性控制多少列数据存放在聚簇索引中，多少数据存放在溢出页中。

COMPRESSED行格式支持最大3072字节索引前缀。

#### DYNAMIC行格式存储特性

COMPRESSED行格式时COMPACT行格式的变种，所以存储特性是一样的。