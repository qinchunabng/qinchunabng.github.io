---
layout: post
title: 缓存中常见的问题及的解决方案
categories: [Redis]
description: 缓存穿透的解决方法
keywords: Redis, 缓存
---

## 缓存穿透

缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存不会生效，请求直接请求到数据库。常见的解决方案有两种：
- 缓存空对象
  - 优点：实现简单，维护方便
  - 缺点：
    - 额外的内存消耗
    - 可能造成短期的不一致
  
  ![缓存空对象示意图](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/redis/cache_through_1.png?raw=true)
- 布隆过滤器
  - 优点：内存空间占用少，没有多余的key
  - 缺点：
    - 实现复杂
    - 存在误判的可能
  
  ![布隆过滤器示意图](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/redis/cache_through_2.png?raw=true)

## 缓存雪崩

缓存雪崩是指在同一时段大量的缓存key同时失效或者redis服务宕机，导致大量请求达到数据库，带来巨大的压力。

解决方案：

- 给不同的key的ttl添加随机值
- 利用redis集群提高服务的可用性
- 给缓存业务添加降级限流策略
- 给业务添加多级缓存

## 缓存击穿

缓存击穿问题也叫热点key问题，就是一个被高并发并且缓存重建业务比较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

常见的解决方案：
- 互斥锁
  
  ![互斥锁流程图](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/redis/cache_breakdown_1.png?raw=true)

  互斥锁的处理方式的流程如上图所示。线程1查询缓存未命中，先获取互斥锁，获取成功之后，再去查询数据库重建缓存，最后再释放锁。线程2同时也查询缓存并且未命中，然后获取锁失败，休眠一段时间后再重试，直到线程一释放锁之后，重新命中缓存。这种方式在同一段时间内，只有一个线程能获取锁成功，查询数据库重建缓存，其他线程都需要等待。但是这个方案有个问题，如果有很多请求同时进来，并且缓冲重建的时间比较长，其他线程都需要等待再重试，性能会比较差。
  

- 逻辑过期

  ![逻辑过期流程图](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/redis/cache_breakdown_2.png?raw=true)

  逻辑过期的处理方式就是缓冲数据不加ttl过期时间，而是缓存数据中加上一个逻辑过期时间的字段，查询的时候判断这个逻辑时间是否过期，处理流程如上图所示。线程1查询缓存未命中，先获取互斥锁，然后开启一个新线程2，返回旧数据。线程2异步查询数据库重建缓存，重置逻辑过期时间，再去释放锁。在线程1执行的时候，线程3也去查询缓存未命中，然后也去获取锁，由于锁被线程1获取了，所以获取锁会失败。但是线程2并不会等待，而是直接返回旧数据。线程3在线程2重建缓存之后再去查询，就会命中缓存，获取到最新的数据。

两种实现方式的对比：

|解决方案|优点|缺点|
|:-:|:-:|:-:|
|互斥锁|没有额外内存消耗，保证一致性，实现简单|线程需要等待，性能受到影响，可能有死锁风险|
|逻辑过期|线程无需等待，性能较好|不保证一致性，有额外内存消耗，实现复杂|