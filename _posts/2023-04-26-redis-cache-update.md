---
layout: post
title: 缓存更新策略
categories: [Redis]
description: 缓存更新策略
keywords: Redis, 缓存
---

## 缓存更新策略

||内存淘汰|超时剔除|主动更新|
|:--:|:--:|:--:|:--:|
|说明|不用自己维护，利用redis的内存淘汰机制，当内存不够时自动淘汰部分数据，下次查询时更新缓存|给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存|编写业务逻辑，在修改数据库的同时，更新缓存|
|一致性|差|一般|好|
|维护成本|无|低|高|

业务场景：
- 低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存。
- 高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情缓存。

### 主动更新策略

- Cache Aside Pattern

  由缓存的调用者，在更新数据库的同时更新缓存

- Read/Write Through Pattern
  
  缓存与数据库整合一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。

- Write Bebind Caching Pattern
  
  调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证数据最终一致。

对比三个策略：Cache Aside Pattern需要开发者写代码来实现，优点是由开发者自己控制，缺点是维护成本较高；Read/Write Through Pattern优点是不需要开发者自己来维护缓存，缺点是开发一个服务来维护内存，难度比较大，而且目前市面上也没有现成的可以使用；Write Bebind Caching Pattern优点是异步更新缓存效率较高，可以合并多个更新操作，缺点是在异步更新缓存之前或者异步更新缓存出现故障会出现缓存不一致的问题。综合对比，Cache Aside Pattern胜出。

使用Cache Aside Pattern需要考虑三个问题：

1. 删除缓存还是更新缓存？
  
   - 更新缓存：每次更新数据库都更新缓存，无效写操作较多
   - 删除缓存：更新数据库时让缓存失效，查询时再更新缓存
  
2. 如何保证缓存与数据库的操作的同时成功或失败？
   
   - 单体系统：将缓存和数据库操作放在一个事务
   - 分布式事务：利用TCC等分布式事务解决方案
  
3. 先操作缓存还是先操作数据库？
   
   - 先删除缓存，再操作数据库
     
     ![先删缓存，再操作数据库1](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/redis/remove_cache_first_1.png?raw=true)
     
     如图，正常情况下操作流程是，线程1先删除缓存，再更新数据库数据为20。线程2再来查询缓存，发现缓存种没有对应数据，查询数据库，获取20并且缓存更新为20。

     ![先删缓存，再操作数据库2](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/redis/remove_cache_first_2.png?raw=true)

     但是，由于线程1再删除缓存和更新数据的时候并没有加锁，这中间就可能出现如上图的情况。线程1先删除缓存，这时线程查询缓存，发送缓存没有命中，然后查询数据库并更新缓存，线程2执行完毕之后，线程1才更新数据库数据为20，这时就出现缓存不一致的现象，缓存中还是旧的数据。因为第二步和第三步操作都是操作redis缓存，相比数据库操作是要快的，所以这种情况发送的概率还是很高的。

   - 先操作数据库，再删除缓存
     
     ![先操作数据库，再删除缓存1](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/redis/remove_cache_behind_1.png?raw=true)

     先操作数据库，再删除缓存，如上图所示：线程1先修改数据库数据为20，然后再删除缓存；线程2再去查询缓存，缓存未命中，去查询数据库得到20，更新缓存为20。

     ![先操作数据库，再删除缓存2](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/redis/remove_cache_behind_2.png?raw=true)
     
     但是这种模式，存在一种特殊情况，如上图所示：线程1缓存失效查询缓存未命中，查询数据库得到10；此时线程2更新数据库为20，然后删除缓存，最后线程1再更新缓存为10。这次缓存数据为旧数据，出现数据不一致。不过，这种情况的发生需要满足三个条件：
     1. 两个线程并行执行。
     2. 线程1在查询的时候恰好缓存失效。
     3. 在线程1在查询数据库后更新缓存之前，在这期间线程2更新了数据库，并且删除了缓存。
     
     由于更新缓存的操作是很快的，比更新数据库要快很多，在更新缓存期间发生更新数据库和删除缓存的可能性是很低的。所以上面三个条件同时满足的概率并不高。虽然发生概率并不高，但是还是有可能会发生，所以可以在更新缓存的时候设置一个超时时间，即使出现缓存不一致的问题，到了超时时间，脏数据就会被清理掉。
     
     综合对比，先删除数据库在删除缓存比先删除缓存，再删除数据库要更好一些。

### 总结

缓存更新策略的最佳实践方案：

1. 低一致性需求：使用redis自带的内存淘汰机制
2. 高一致性需求：主动更新，并以超时剔除机制作为兜底方案
   - 读操作
     - 缓存未命中则直接返回
     - 缓存未命中则查询数据库，并写入缓存，设定超时时间
   - 写操作
     - 先写数据库，再删除缓存
     - 要确保数据库与缓存操作的原子性