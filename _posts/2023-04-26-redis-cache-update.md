---
layout: post
title: 缓存更新策略
categories: [Redis]
description: 缓存更新策略
keywords: Redis, 缓存
---

## 缓存更新策略

||内存淘汰|超时剔除|主动更新|
|:--:|:--:|:--:|:--:|
|说明|不用自己维护，利用redis的内存淘汰机制，当内存不够时自动淘汰部分数据，下次查询时更新缓存|给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存|编写业务逻辑，在修改数据库的同时，更新缓存|
|一致性|差|一般|好|
|维护成本|无|低|高|

业务场景：
- 低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存。
- 高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情缓存。

### 主动更新策略

- Cache Aside Pattern

  由缓存的调用者，在更新数据库的同时更新缓存

- Read/Write Through Pattern
  
  缓存与数据库整合一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。

- Write Bebind Caching Pattern
  
  调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证数据最终一致。

对比三个策略：Cache Aside Pattern需要开发者写代码来实现，优点是由开发者自己控制，缺点是维护成本较高；Read/Write Through Pattern优点是不需要开发者自己来维护缓存，缺点是开发一个服务来维护内存，难度比较大，而且目前市面上也没有现成的可以使用；Write Bebind Caching Pattern优点是异步更新缓存效率较高，可以合并多个更新操作，缺点是在异步更新缓存之前或者异步更新缓存出现故障会出现缓存不一致的问题。综合对比，Cache Aside Pattern胜出。

使用Cache Aside Pattern需要考虑三个问题：

1. 删除缓存还是更新缓存？
  
   - 更新缓存：每次更新数据库都更新缓存，无效写操作较多
   - 删除缓存：更新数据库时让缓存失效，查询时再更新缓存
  
2. 如何保证缓存与数据库的操作的同时成功或失败？
   
   - 单体系统：将缓存和数据库操作放在一个事务
   - 分布式事务：利用TCC等分布式事务解决方案
  
3. 先操作缓存还是先操作数据库？
   
   - 先删除缓存，再操作数据库
     
     ![先删缓存，再操作数据库1](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/redis/remove_cache_first_1.png?raw=true)
     
     如图，正常情况下操作流程是，线程1先删除缓存，再更新数据库数据为20。线程2再来查询缓存，发现缓存种没有对应数据，查询数据库，获取20并且缓存更新为20。

     ![先删缓存，再操作数据库2](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/redis/remove_cache_first_2.png?raw=true)

     但是，由于线程1再删除缓存和更新数据的时候并没有加锁，这中间就可能出现如上图的情况。线程1先删除缓存，这时线程查询缓存，发送缓存没有命中，然后查询数据库并更新缓存，线程2执行完毕之后，线程1才更新数据库数据为20，这时就出现缓存不一致的现象，缓存中还是旧的数据。因为第二步和第三步操作都是操作redis缓存，相比数据库操作是要快的，所以这种情况发送的概率还是很高的。

   - 先操作数据库，再删除缓存
     
     
  