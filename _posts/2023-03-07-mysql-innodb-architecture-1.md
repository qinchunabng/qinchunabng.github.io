---
layout: post
title: InnoDB架构（一）
categories: [MySQL]
description: InnoDB架构
keywords: MySQL, InnoDB
---

## InnoDB架构

![InnoDB架构图](https://raw.githubusercontent.com/qinchunabng/qinchunabng.github.io/master/images/posts/mysql/innodb-architecture-8-0.png)

## InnoDB内存结构

### 缓存池

缓存池是主存中用来缓存InnoDB所访问表和索引数据的内存区域。缓存池会缓存经常访问的数，这样这些数据就不需要进行磁盘I/O。在专用服务器上，高达80%的内存分配给缓存池。

为了大容量读操作效率，缓存池会被分成可以容量多行数据的页。为了提供缓存的管理效率，缓存池的页之间是通过链表进行关联的，并且使用LRU算法对旧数据进行处理。

了解如何利用缓存池的将经常访问的数据留在内存中，是MySQL优化的一个重要方面。

### 缓存池的LRU算法

缓存池用的是LRU算法的变种，当需要往缓存池插入新的页时，最近最少使用的页会被回收，新的页会被添加页链表的中间，这个中间点把链表分为两个部分：
- 中间点的前面一部分，是最近访问过的页
- 中间点的后面一部分，是最近访问比较少的页
  
![缓存池链表](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/mysql/innodb-buffer-pool-list.png?raw=true)

这个算法将经常被访问的页放到新子链表中，旧的子链表中放访问较少的页，这些页可能会被淘汰回收。
默认情况，这个算法的操作如下：
- 缓存池的3/8是旧的子链表。
- 链表的中间点在新的子链表的尾部，在旧子链表的头部，是新旧的分割点。
- 访问旧子表中的页，会使这个页移动到新子表的头部。如果读取页是用户发起的操作，这个页被置为年轻页，如果读取页是预读操作而读取的则不会。
- 缓存池中没有被访问的页会主键移动到链表的尾部，最终旧的子列表中没有被访问的页会被淘汰回收。
  
默认情况下，被查询操作读取页会被直接放到新的子列表中，这意味着这些数据会在缓冲池停留更长的时间。像mysqldump的操作和不带查询的条件的SELECT这样会导致全表扫描的操作，会将大量的数据放进新子列表中，并淘汰一些旧的数据给新加入的数据腾空间，即使这些数据只访问了一次。类似的，后台预读线程加载的只读取一次的页，也会被放到新的子列表中。这些情况下，会导致一些经常被访问的页被淘汰回收。

### 更新缓冲区

更新缓存是一个特殊的数据结构，当二级索引页不在缓存池中时，将二级索引的变更缓存起来。这些变更都是INSERT,UPDATE和DELETE这样的DML操作导致的，在后面读操作把数据页加载到缓冲池之后会被合并。

![更新缓存](https://github.com/qinchunabng/qinchunabng.github.io/blob/master/images/posts/mysql/innodb-change-buffer.png?raw=true)

不像聚簇索引，二级索引不是唯一的，并且二级索引的数据的插入是以相对随机的顺序进行的。同样的，删除和更新操作可能影响的到二级索引页中不相邻的数据。当其他操作读取被影响的数据到缓存池之后，会合并更新缓存的内容，避免从硬盘将二级索引页读到缓冲池而引起的随机I/O。

在系统空闲的或者关机时，清理操作会将更新的索引页周期性的写入到硬盘中，这种方式比每次执行写操作都写入硬盘要高效的多。

当有大量受影响行和二级索引数据更新时，变更缓存合并可能会花费几个小时。这期间硬盘I/O增加，会影响其他的硬盘读操作。更新缓存合并也可能会在事务提交后或者服务器重启之后发送。

在内存中，更新缓存占用了一部分缓存池。在硬盘中，变更缓存时系统表空间的一部分，当数据库服务器关机时来缓存索引变更。

如果二级索引或者主键包含降序索引列，二级索引不支持更新缓存。

### 配置更新缓冲区

当执行INSERT,UPDATE和DELETE操作，被更新索引列的值（特别是二级索引的）经常都是无序的，需要I/O操作来更新二级索引。更新缓冲区缓存了二级索引的数据，当相关数据也不在缓冲池中，来避免直接从硬盘读数据这样昂贵的I/O操作。缓存的更新在相关数据页加载到缓存池的时候会被合并，更新的页稍后会刷新到硬盘上。InnoDB的主线程会在服务器空闲或者关闭的时候合并更新的缓存。

对于DML这样的会写操作，开启更新缓冲区是很有必要的，能够减少磁盘I/O。

但是更新缓冲区会占用一部分缓存池的内存，减少用来缓存数据页的内存大小。如果缓存池的大小能够缓存的下查询数据，或者你的表只有少量的二级索引，可以关闭更新缓冲区。如果缓存池能够一直容得下所有的查询数据，更新缓冲区不会带来额外的开销，因为更新缓冲器只会在数据页不在缓冲池的时候才会被使用到。

通过`innodb_change_buffering`配置可以设置更新缓冲区对InnoDB的哪些操作生效,你可以配置是否缓存插入、删除操作（索引记录标记为删除）和清理操作（索引记录被物理删除）。更新操作是insert和delete的作何。`innodb_change_buffering`的默认值是all。

`innodb_change_buffering`取值有以下几种：

- all
  
  默认值，会缓存插入、标记删除和清理操作。

- none
  
  不缓存任何操作。

- inserts
  
  缓存插入操作。

- deletes
  
  缓存标记删除操作。

- changes
  
  缓存插入和标记删除操作。

- purges
  
  缓存后台执行的清理操作。

你可以在配置文件(my.cnf或my.ini)中设置`innodb_change_buffering`变量的值，或者通过SET GLOBAL语句动态设置。改变配置的值只对后面的操作生效。

### 配置更新缓冲区最大大小

`innodb_change_buffer_max_size`变量可以配置更新缓冲区占缓存池的百分比，默认值是25，最大值可设置为50。

当你的数据库有大量的insert,update和delete操作时，考虑增加` innodb_change_buffer_max_size`，因为合并更新缓存的操作一般不是立即执行的，可能会导致更新缓冲区超过最大限制。

如果MySQL中的数据主要是一些查询的静态数据，或者更新缓存消耗了太多的缓冲池的内存，导致查询的数据页无法缓存，这个时候应当减小` innodb_change_buffer_max_size`。

`innodb_change_buffer_max_size`是动态的，修改` innodb_change_buffer_max_size`不需要重启服务就可以生效。

## 自适应哈希索引

自适应哈希索引使得InnoDB更像一个内存数据库，并且不需要牺牲事务的特性和可靠性。通过`innodb_adaptive_hash_index`开启自适应哈希索引，在MySQL启动时通过`--skip-innodb-adaptive-hash-index`关闭自适应哈希索引。

哈希索引是通过索引的前缀构建的，前缀可以是任何长度。经常访问的索引页会构建哈希索引。

如果内存中的数据可以全部放到主存中，哈希索引能极大的提升查找速度，使索引就像指针一样。InnoDB有一个监控索引查询的机制，如果InnoDB发现构建哈希索引能够加快查询，InnoDB就会自定创建哈希索引。

有些工作场景下，哈希索引带来的性能提升是大大超过监控索引和维护哈希索引带来的额外开销的。在一些场景下，比如多并发join查询，哈希索引查询可能会发生冲突。对于一些hash索引不能带来性能提升的场景，可以关闭自适应hash索引，来减少不必要的性能开销。因为无法预测哈希索引是否能给系统带来性能提升，所以需要在开启和关闭自适应哈希索引的情况下进行基准测试，来判断是否需要开启自适应hash索引。

## 日志缓冲区

日志缓冲区是保存需要写入到硬盘种日志文件的内存区域。通过`innodb_log_buffer_size`变量可以设置日志缓冲区的大小，默认是16MB。日志缓冲区的内容会周期性的刷新到硬盘。一个大的日志缓冲区可以避免一个大事务在执行commit操作之前不需要将redo日志写入到硬盘。因此，如果你有的update,insert和delete大量数据行的操作，增加日志缓冲区的大小来减少磁盘I/O。

`innodb_flush_log_at_trx_commit`变量控制日志缓存区如何刷盘，`innodb_flush_log_at_timeout`变量控制日志刷盘的频率。
